---
title: "Analysis 4: von Bertalanffy Individual Growth Analysis"
author: "Joe Gunn"
date: "2022-07-28"
output: html_document
---

# Project: Effects of admixture on fitness in Neosho Bass populations 
<font size="+1">We assessed the effect of admixture on fitness in two stream populations within the native range of the Neosho Bass (<i>M. velox</i>) which are known to have extensively hybridized with Smallmouth Bass (<i>Micropterus dolomieu</i>). Specifically, we used 14 microsatellite loci in a Bayesian analysis of population structure to estimate proportions of interspecific ancestry in individuals collected from Big Sugar Creek and the Elk River in southwestern Missouri (Central Interior Highlands ecoregion (CIH), North America). We used ancestry inference to identify fish as "Pure Neosho Bass", "Pure Smallmouth Bass", or "Admixed". For each group, we measured age and total length and projected individual growth using the standard paramaterization of the von Berlanffy growth model, comparing average theoretical maximum length among groups. Finally, we used calculated a body condition as a proxy of fitness and generated heterozygosity-fitness correlations of body condition across the global dataset, within stream populations, and within ancestry groups. We ultimately sought to understand the short-term genetic consequences of admixture for Neosho Bass populations in order to better inform management and long-term viability of distinct, economically and ecologically important sportfish species in the CIH.</font>

## Specific Aim: von Bertalanffy individual growth analysis
For this aim, paramaterized the von Bertlanffy individual growth model (von Bertlanffy 1983) for Neosho Bass in Big Sugar Creek and Elk River based on total length (tl_alive) and consensus age data to assess growth rates in inferred groups of interest. We started by using the Dahl-Lee linear back-calculation model We started by quantifying overall growth rate and maximum theoretical total length for all fish collected across both streams. Next, we quantified potential differences in growth by (1) individual sex (male or female) and (2) by stream (Big Sugar Creek or Elk River) to account for variation which may bias results in other groups. Finally, we assessed differences in growth based on ancestry group membership as inferred by STRUCTURE analysis in Analysis 3 (Neosho Bass, Smallmouth Bass, Admixed). For all growth assessments, we included linear back-calculated length-at-age estimates for large, older fish to increase sample size.

## Phases of Analysis
### Phase 1: Linear back-calculation
### Phase 2: von Bertlanffy growth analysis

### Libraries needed for analysis
```{r}
library(tidyverse)
library(cowplot)
library(readxl)
library(RFishBC) #v.0.2.4
library(FSA) #v.0.8.32
library(boot)
library(car)
library(rlist)
```

### maybe
library(nlme)
library(lme4)
library(factoextra)
library(MASS)
library(logihist)
library(ggpubr)
library(DescTools)

## PHASE 1: LINEAR BACK CALCULATION
In this phase of analysis, we conduct linear back-calculation on a subset of relatively high-age fish in our dataset to generate estimates of total length for fish at earlier ages. These estimates are not to be considered independent measurements of age and length, because they are calculated based on the assumption of a direct, one-to-one proportional relationship between an individual's total length and the radii of each annulus in the individual's otolith. Each back-calculated length is therefore an estimate of that individual's length at an earlier age. However, given a large sample size, these estimates can be used to approximate or represent lower age estimates within a population.

### STEP 1: Set "device type" in the package RFishBC (Ogle, 2022) so that the GUI will be readible by MAC OS; run the Rmd chunk below.
In this step, I needed to run a line of code built into the RFishBC package to set the computing device type to "X11", which allows the package's GUI to run on a MAC OS. 

##### Set device type to MAC (X11):
```{r}
RFBCoptions(deviceType = "X11")
```

### STEP 2: Copy raw otolith images into the working directory (`growth_analysis/`).
The RFishBC package requires that raw otolith images being read for back-calculation are placed in the working directory for the Rmd file, which, in this case, is the growth_analysis folder. We therefore *temporarily* copied all raw otolith camera images (`../raw_data/otolith_images/raw/`) into the current working directory.

### STEP 3: Estimate radial measurements of otolith annuli.
In this step, we run the function "digitizeRadii()" from the package RFishBC on each otolith image independently (we list the function for all unique image IDs), which allows interactive radial measurements by drawing radius transects directly on the image. The user is asked to (1) input a unique image ID, (2) draw a linear transect from the nucleus (centroid) to the outer edge of the otolith, and (3) identify each annulus along the transect to match the inferred age of the fish. One output of the function is a data table ("radii", an element of the .rds object) giving the total radius of the otolith and the radii for each individual annulus.

We input the ID given for each otolith (e.g., FBS01, FBS02, etc.). We drew transects from the centroid to the outer edge of the otolith on the same side and just above the sulcus (see Figure S2 in the final manuscript) to standardize radii for each otolith. We identified annuli by placing a reference point on the outermost edge of each annulus. For any otoliths that were cracked (and we could not reliably determine the radius from the nucleus to an otolith edge), cloudy or obscured, or without clearly defined edges, we did not include those samples, and they are indicated within the code chunk.

#### 3a: Estimate radial measurements for Big Sugar Creek samples; run the Rmd chunk below:
In this step, we estimate radial measurements for the Big Sugar Creek samples only.

##### Run linear-back calculation on each image and generate output radius data:
```{r}
# Run linear back-calculation for Big Sugar Creek samples ("FBS")
digitizeRadii("FBS01.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS02.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS03.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS04.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS05.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS06.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS07.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS08.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS09.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS10.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS11.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS12.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS13.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS14.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS15.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS16.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS17.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS18.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS19.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS20.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS21.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS22.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS23.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS24.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS25.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS26.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS27.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS28.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS29.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS30.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS31.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS32.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS33.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS34.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS35.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS36.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS37.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS38.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS39.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS40.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS41.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS42.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS43.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS44.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS45.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS46.PNG", edgeIsAnnulus = F)
```

<b>Samples used for back-calculation</b>: <i>N</i> = 46

#### 3b: Estimate radial measurements for Elk River samples; run the Rmd chunk below:
In this step, we estimate radial measurements for the Elk River samples only.

```{r}
# Run linear back-calculation for Elk River samples ("FER")
digitizeRadii("FER01.PNG", edgeIsAnnulus = F)
digitizeRadii("FER02.PNG", edgeIsAnnulus = F)
digitizeRadii("FER03.PNG", edgeIsAnnulus = F)
digitizeRadii("FER04.PNG", edgeIsAnnulus = F)
digitizeRadii("FER05.PNG", edgeIsAnnulus = F)
digitizeRadii("FER06.PNG", edgeIsAnnulus = F)
digitizeRadii("FER07.PNG", edgeIsAnnulus = F)
#digitizeRadii("FER08.PNG", edgeIsAnnulus = F) ## Cracked otolith, unable to reliably determine radius from nucleus to edge
digitizeRadii("FER09.PNG", edgeIsAnnulus = F)
digitizeRadii("FER10.PNG", edgeIsAnnulus = F)
digitizeRadii("FER11.PNG", edgeIsAnnulus = F)
digitizeRadii("FER12.PNG", edgeIsAnnulus = F)
digitizeRadii("FER13.PNG", edgeIsAnnulus = F)
digitizeRadii("FER14.PNG", edgeIsAnnulus = F)
digitizeRadii("FER15.PNG", edgeIsAnnulus = F)
digitizeRadii("FER16.PNG", edgeIsAnnulus = F)
digitizeRadii("FER17.PNG", edgeIsAnnulus = F)
digitizeRadii("FER18.PNG", edgeIsAnnulus = F)
digitizeRadii("FER19.PNG", edgeIsAnnulus = F)
digitizeRadii("FER20.PNG", edgeIsAnnulus = F)
digitizeRadii("FER21.PNG", edgeIsAnnulus = F)
digitizeRadii("FER22.PNG", edgeIsAnnulus = F)
digitizeRadii("FER23.PNG", edgeIsAnnulus = F)
digitizeRadii("FER24.PNG", edgeIsAnnulus = F)
digitizeRadii("FER25.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER26.PNG", edgeIsAnnulus = F)
digitizeRadii("FER27.PNG", edgeIsAnnulus = F)
digitizeRadii("FER28.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER29.PNG", edgeIsAnnulus = F)
digitizeRadii("FER30.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER31.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER32.PNG", edgeIsAnnulus = F)
digitizeRadii("FER33.PNG", edgeIsAnnulus = F)
digitizeRadii("FER34.PNG", edgeIsAnnulus = F)
digitizeRadii("FER35.PNG", edgeIsAnnulus = F)
digitizeRadii("FER36.PNG", edgeIsAnnulus = F)
digitizeRadii("FER37.PNG", edgeIsAnnulus = F)
digitizeRadii("FER38.PNG", edgeIsAnnulus = F)
digitizeRadii("FER39.PNG", edgeIsAnnulus = F)
digitizeRadii("FER40.PNG", edgeIsAnnulus = F)
digitizeRadii("FER41.PNG", edgeIsAnnulus = F)
digitizeRadii("FER42.PNG", edgeIsAnnulus = F)
digitizeRadii("FER43.PNG", edgeIsAnnulus = F)
digitizeRadii("FER44.PNG", edgeIsAnnulus = F)
digitizeRadii("FER45.PNG", edgeIsAnnulus = F)
digitizeRadii("FER46.PNG", edgeIsAnnulus = F)
#digitizeRadii("FER47.PNG", edgeIsAnnulus = F) # Cracked otolith, missing sulcus, unable to reliably determine radius from nucleus to edge
digitizeRadii("FER48.PNG", edgeIsAnnulus = F)
digitizeRadii("FER49.PNG", edgeIsAnnulus = F)
digitizeRadii("FER50.PNG", edgeIsAnnulus = F)
digitizeRadii("FER51.PNG", edgeIsAnnulus = F)
digitizeRadii("FER52.PNG", edgeIsAnnulus = F)
digitizeRadii("FER53.PNG", edgeIsAnnulus = F)
digitizeRadii("FER54.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER55.PNG", edgeIsAnnulus = F)
digitizeRadii("FER56.PNG", edgeIsAnnulus = F)
digitizeRadii("FER57.PNG", edgeIsAnnulus = F)
digitizeRadii("FER58.PNG", edgeIsAnnulus = F)
digitizeRadii("FER59.PNG", edgeIsAnnulus = F)
digitizeRadii("FER60.PNG", edgeIsAnnulus = F)
digitizeRadii("FER61.PNG", edgeIsAnnulus = F)
digitizeRadii("FER62.PNG", edgeIsAnnulus = F)
digitizeRadii("FER63.PNG", edgeIsAnnulus = F)
digitizeRadii("FER64.PNG", edgeIsAnnulus = F)
digitizeRadii("FER65.PNG", edgeIsAnnulus = F)
digitizeRadii("FER66.PNG", edgeIsAnnulus = F)
digitizeRadii("FER68.PNG", edgeIsAnnulus = F)
digitizeRadii("FER69.PNG", edgeIsAnnulus = F)
#digitizeRadii("FER70.PNG", edgeIsAnnulus = F) # Poor image quality
digitizeRadii("FER71.PNG", edgeIsAnnulus = F)
```

<b>Samples used for back-calculation</b>: <i>N</i> = 62

#### 3c: Remove all copied raw otolith images from the working directory.

#### 3d: Move all .rds files generated from the digitizeRadii() function into a new folder: `data/bc_rds/`

### STEP 4: Compile and clean all radius measurements stored in .rds files
In this step, we wrote a for-loop to extract the "radii" elements from each of the .rds files generated by the digitizeRadii() function used in Step 3 above. All radii data were for each sample were then compiled into a single dataframe ("bc"). We then cleaned, filtered, and merged the bc data with total length data to perform linear back-calculation of length-at-age.

#### 4a: Extract radial measurements for each sample from .rds files and compile into a single data frame for back-calculation

##### Extract radial measurements and compile into single dataframe:
```{r}
# List rds filers
rds <- list.files(paste("data/bc_rds/"),
                  pattern=".rds$")

# Generate data frame of rds file names
rds_files <- data_frame(rds)

# Generate an empty list to store "radii" data frame elements from .rds files
rds_list <- list()

# Run for loop on all .rds files to extract radii data frame and add to the rds_list (defined above)
for(ii in 1:nrow(rds_files)) {
  
  ## paste the readRDS() function so that it calls each .rds file in the rds files data frame
  read_rds <- readRDS(paste("data/bc_rds/", rds_files[ii,"rds"], sep = ""))$radii
  
  ## Fill the empty list with the iterative output of each read_rds object (defined above)
  rds_list[[paste0("element",ii)]] <- read_rds
  
}

# Concatenate all data frame elements in the list using the list.rbind() function from the package "rlist"
bc <- data.frame(list.rbind(rds_list))
```

#### 4b: Clean and filter radial measurement data for downstream back-calculation; run the Rmd chunk below.
In this step, we clean and filter the radial measurement data so that it can be seamlessly merged with the full ancestry dataset (See Step 5).

Data from the compiled rds files include: 

   1. "sample_id": same as in metadata and genotype data (followed by "structure_number"; see Analysis 3, Phase 1, step 1e)
   2. "consensus age": ultimate age estimate based on consensus of three agers, Eddie, Joe, and Michael 
   3. "annulus": each annulus for each otolith
   4. "annulus_radius": radius of each annulus 
   5. "otolith_radius": total radius of the whole otolith

##### Clean and filter, and merge radial measurement data:
```{r}
# Omit rownames
rownames(bc) <- NULL

# Omit empty "reading" column
bc <- bc %>%
  select(-c(reading))

# Modify column names to be more sensible
colnames(bc) <- c("sample_id", "consensus_age", "annulus", "annulus_radius", "otolith_radius")

# Here, I added a row for each of the samples we did not do radius measurements for. I included these as individual rows, because without them, the merging procedure in step 5 results in "NA" values for these individuals since they do not have radial measurements and cannot be used for back-calculation.
bc[451,] <- c("FER08", "2", "2", "1.0000000", "1.0000000")
bc[452,] <- c("FER47", "2", "2", "1.0000000", "1.0000000")
bc[453,] <- c("FER70", "2", "2", "1.0000000", "1.0000000")

# Convert characters to factors
bc <- bc %>%
  mutate(sample_id = factor(sample_id)) %>%
  mutate(consensus_age = as.numeric(consensus_age)) %>%
  mutate(annulus = as.numeric(annulus)) %>%
  mutate(annulus_radius = as.numeric(annulus_radius)) %>%
  mutate(otolith_radius = as.numeric(otolith_radius))

# Save radius data for donwtream analyses
save(bc, file = "data/bc_data/bc.Rda")
```

### STEP 5: Merge radius data with full ancestry data (Analysis 3) and perform linear back-calculation 
In this step, we merge the annuli radii data generated above with the full ancestry data generated in Analysis 3, and we perform linear back-calculation using the Dahl-Lea direct proportion model with total length. We estimate length-at-age for each individual fish (age of the fish at all earlier ages) based on the assumed proportional relationship between total length of the fish at a given age and the radius of the fish at the corresponding annulus deposition.

#### 5a: Merge radius data with full ancestry data; run the Rmd chunk below.

##### Merge radius data with full ancestry data:
```{r}
# Load in full ancestry data curated in Analysis 3 
load("../ancestry_analysis/data/processed_ancestry_data/full_ancestry_data.Rda")

# Filter dataset to keep only fish with total length and consensus age data ("sample"; NOT "reference")
full_ancestry_data <- full_ancestry_data %>%
  filter(population == "sample")

# Load in bc data calculated in Steps 3-4 above
load("data/bc_data/bc.Rda")

# Merge full ancestry data with bc data 
bc_data <- full_join(full_ancestry_data, 
                     bc, 
                     by = c("sample_id", "consensus_age"))

# Perform back-calculation using the Dahl-Lee model
bc_data <- bc_data %>%
  mutate(bc_ratio = annulus_radius/otolith_radius) %>%
  mutate(bc_tl = tl_alive*(annulus_radius/otolith_radius))
```

#### 5b: Remove all length data corresponding to an annulus-to-otolith radial ratio of 1.00; run the Rmd chunk below.
In this step, we standardize all total length data such that the consensus age of the fish (determined by estimating the number of annuli deposited on each otolith) corresponds to the radial measurement of the last deposited otolith, rather than the edge of the otolith. For each fish, the margin of the otolith beyond the final annulus represents additional deposition of calcium carbonate over the course of the year; the exact timing of yearly deposition is dependent on the birth date (exact day) of the fish, which may be variable among fish in our sample. Thus, to standardize length-at-age, we only include back-calculated age data corresponding to each annulus, and not to the edge of the otolith. We therefore do not use the observed lengths of fish collected in the field.

From this point further, the column for "consensus_age", which was the age agreed upon for each fish based on the number of annuli present on the otolith, was considered synonmous with the column "annulus", with the highest annulus number for each sample being equivalent to the consensus age. Each lesser annulus number represents earlier ages for each fish, for which total length is back-calculated.

##### Remove fish with annulus-to-otolith radial ratio of 1.00:
```{r}
# Remove fish with annulus-to-otolith radial ratio of 1.00
full_bc_data <- bc_data %>%
  filter(bc_ratio != 1.0000000)

## Verify that the three samples not back-calculated ((FER08, FER47, FER70) were removed from the dataset

# Samples in full_bc_data but not in bc_data
full_bc_data %>% 
  filter(!full_bc_data$sample_id %in% bc_data$sample_id)

# Samples in bc_data but not in full_bc_data
bc_data %>% 
  filter(!bc_data$sample_id %in% full_bc_data$sample_id)

# Save full bc data for downstream growth analysis
save(full_bc_data, file = "data/bc_data/full_bc_data.Rda")
```

After this step, three samples (FER08, FER47, FER70) were omitted from analyses, because we were unable to measure radii for back-calculation (see Steps 3-4 above). These samples were not included in any growth models.

<b>Final back-calculation data summary</b>:
<i>N</i><sub>samples</sub> = 337

## PHASE 2: VON BERTALANFFY GROWTH ANALYSIS
In this phase of the analysis, we paramaterize the von Bertalanffy growth equation using back-calculated total length and consensus age of samples in the Elk River and Big Sugar Creek to assess patterns of growth in groups of interest (specifically, between the two streams, between sexes, and among genetic ancestry groups). We first quantify overall growth rate and maximum theoretical total length for all fish in the dataset to understand average growth rates across the populations of interest. Next, we quantify any potential differences in growth by (1) individual sex (male or female) or (2) by stream (Big Sugar Creek or Elk River) to account for variation which may bias results in other groups. Finally, we assess differences in growth based on ancestry group membership as inferred by STRUCTURE analysis in Analysis 3 (Neosho Bass, Smallmouth Bass, Admixed). For all growth assessments, we include linear back-calculated length-at-age estimates for large, older fish to increase sample size.

### STEP 1: Define the von Bertlanffy growth model; run the Rmd chunk below.
In this step, we use the vbFuns() function in the R package FSA to generate a function using the "typical" parameterization of the von Bertlanffy equation.

##### Define von Bertalanffy growth model:
```{r}
vb <- vbFuns(param = "Typical")
```

### STEP 2: Parameterize the von Bertalanffy model for study groups of interest.

#### 2a: Generate global growth model.
In this step, we parameterize the von Bertalanffy growth model for the global dataset (all samples), including all fish in the study (across Big Sugar Creek and Elk River, both sexes and all ancestry groups).

##### 2a.1. Load full back-calculation data and generaate model starting values; run the Rmd chunk below.

##### load data and generate starting values
```{r}
# Load full bc data
load("data/bc_data/full_bc_data.Rda")

# Generate starting values for optimizing the von Bertalanffy model
global_starts <- vbStarts(bc_tl ~ annulus, 
                            data = full_bc_data)
```

<b>Starting values used for global model</b>: <br>

<b>Linf</b>: 382.0127 <br>
<b>K</b>: 0.4094681 <br>
<b>t0</b>: -0.07894399 <br>

##### 2a.2. Model growth for the global dataset and extract model coefficients; run the Rmd chunk below.
In this step, we run the non-linear von Bertalanffy model for the global dataset and extract model coefficients from the summary table given with the summary() function.

##### Model von Bertalanffy growth:
```{r}
# Run von Bertalanffy growth model using back-calculated total length, modeled by annulus number (consensus age)
global <- nls(bc_tl ~ vb(annulus,
                         Linf,
                         K,
                         t0), 
              data = full_bc_data, 
              start = global_starts)

# Extract global data coefficients
global_coefficients <- summary(global)
```
<b>Parameter estimates for global model</b>: <br>

<b>Linf</b>: 440.94667 <br>
<b>K</b>: 0.28338 <br>
<b>t0</b>: -0.30329 <br>

Parameter estimates are given in Table S3a in the final manuscript.

##### 2a.3. Perform bootstrapping of global data to estimate 95% confidence intervals around each parameter estimate; run the Rmd chunk below.
In this step, we perform bootstrapping the global dataset with 9999 bootstrap replicates and calculate 95% confidence intervals around the parameter estimates given in the global model (see Step 2a.2).

```{r}
# Conduct bootstrapping on parameter estimates
set.seed(34349) # Set seed so that results are reproducible
global_bootstrap <- Boot(global, 
                         R = 9999)

# Calculate bootstrapped 95% confidence intervals for parameter estimates
global_confint <- confint(global_bootstrap, 
                          level = 0.95)
```
<b>Confidence intervals for global parameter estimates</b>: <br>

<b>Linf</b>: 408.4898281 - 485.3221992 <br>
<b>K</b>: 0.2287383 - 0.3429249 <br>
<b>t0</b>: -0.5030147 - 0.1412999 <br>

Results from bootstrapping and confidence intervals are given in Table S3a in the final manuscript.

##### 2a.4. Perform bootstrapping of predicted average length-at-age values and calculate 95% confidence intervals; run the Rmd chunk below.
In this step, we perform bootstrapping over average length-at-age estimates predicted for the dataset and calculate 95% confidence intervals around the parameter estimates.

##### Conduct bootstrapping over predicted values.
```{r}
# Define function to predict average length-at-age values for each age (to plot the best fit curve for the von Bertlanffy growth model)
predict_function <- function(x) {
  predict(x, 
          data.frame(annulus = annuli))
}

# Define range of theoretical annulus values over which to calculate length-at-age
annuli <- seq(-1, 15, by = 0.2)

# Conduct bootstrapping with 9999 bootstrap replicates to calculate confidence intervals around the best fit curve
global_iboot <- Boot(global, 
                     f = predict_function,
                     R = 9999)

# Calculate bootstrapped 95% confidence intervals for all parameter estimates
global_iconfint <- confint(global_iboot, 
                           level = 0.95)

# Predict average back-calculated length-at-age for all fish based on model fit and confidence intervals
global_predict <- data.frame(annulus,
                             predict(global, data.frame(annulus = annuli)),
                             global_iconfint)

# Modify column names (lci = lower confidence interval [2.5%]; uci = upper confidence interval [97.5%])
colnames(global_predict) <- c("annulus","fit","lci","uci")

# Save the predicted global model dataset for donwstream analyses
save(global_predict, file = "data/global_data/global_predict.Rda")
```

##### 2a.5. Plot von Bertlanffy growth for the global dataset; run the Rmd chunk below.

##### Plot the von Bertalanffy model for the global dataset: `figures/global.pdf`
```{r}
# Load in global predicted dataset to plot best fit curve
load("data/global_data/global_predict.Rda")

# Load in full back-calculuated data to plot all data points
load("data/bc_data/full_bc_data.Rda")

# Plot von Bertalanffy model
pdf("figures/global.pdf", width = 7, height = 5)

ggplot() + 
  geom_ribbon(data = global_predict, aes(x = annulus, ymin = lci, ymax = uci, fill = "grey", alpha= 0.1), show.legend = F) +
  geom_point(data = full_bc_data, aes(x = annulus, y = bc_tl, fill = "grey"), show.legend = F, size=3, pch=21, position = position_jitter(width = 0.2)) + 
  geom_line(data = global_predict, aes(x = annulus, y = fit)) +
  geom_hline(yintercept = 440.94667, linetype = "longdash", size = 0.8, color = "blue") +
  theme_set(theme_cowplot(12)) +
  scale_fill_manual(values = c("grey")) +
  scale_y_continuous(name = "Back-calculated total length (mm)", limits = c(0,500), expand = c(0,0)) +
  scale_x_continuous(name = "Annulus (years)", expand = c(0,0), limits = c(0,15), breaks = seq(0,15,1)) +
  theme(axis.title = element_text(size = 20)) + 
  theme(axis.text = element_text(size = 16)) +
  theme(axis.title.x = element_blank()) +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

dev.off()
```

