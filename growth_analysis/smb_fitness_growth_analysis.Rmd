---
title: "Analysis 4: von Bertalanffy Individual Growth Analysis"
author: "Joe Gunn"
date: "2022-07-28"
output: html_document
---

# Project: Effects of admixture on fitness in Neosho Bass populations 
<font size="+1">We assessed the effect of admixture on fitness in two stream populations within the native range of the Neosho Bass (<i>M. velox</i>) which are known to have extensively hybridized with Smallmouth Bass (<i>Micropterus dolomieu</i>). Specifically, we used 14 microsatellite loci in a Bayesian analysis of population structure to estimate proportions of interspecific ancestry in individuals collected from Big Sugar Creek and the Elk River in southwestern Missouri (Central Interior Highlands ecoregion (CIH), North America). We used ancestry inference to identify fish as "Pure Neosho Bass", "Pure Smallmouth Bass", or "Admixed". For each group, we measured age and total length and projected individual growth using the standard paramaterization of the von Berlanffy growth model, comparing average theoretical maximum length among groups. Finally, we used calculated a body condition as a proxy of fitness and generated heterozygosity-fitness correlations of body condition across the global dataset, within stream populations, and within ancestry groups. We ultimately sought to understand the short-term genetic consequences of admixture for Neosho Bass populations in order to better inform management and long-term viability of distinct, economically and ecologically important sportfish species in the CIH.</font>

## Specific Aim: von Bertalanffy individual growth analysis
For this aim, paramaterized the von Bertlanffy individual growth model (von Bertlanffy 1983) for Neosho Bass in Big Sugar Creek and Elk River based on total length (tl_alive) and consensus age data to assess growth rates in inferred groups of interest. We started by using the Dahl-Lee linear back-calculation model We started by quantifying overall growth rate and maximum theoretical total length for all fish collected across both streams. Next, we quantified potential differences in growth by (1) individual sex (male or female) and (2) by stream (Big Sugar Creek or Elk River) to account for variation which may bias results in other groups. Finally, we assessed differences in growth based on ancestry group membership as inferred by STRUCTURE analysis in Analysis 3 (Neosho Bass, Smallmouth Bass, Admixed). For all growth assessments, we included linear back-calculated length-at-age estimates for large, older fish to increase sample size.

## Phases of Analysis
### Phase 1: Linear back-calculation
### Phase 2: von Bertlanffy growth analysis

### Libraries needed for analysis
```{r}
library(tidyverse)
library(cowplot)
library(readxl)
library(RFishBC) #v.0.2.4
library(FSA) #v.0.8.32
library(boot)
library(car)
library(rlist)
```

### maybe
library(nlme)
library(lme4)
library(factoextra)
library(MASS)
library(logihist)
library(ggpubr)
library(DescTools)

## PHASE 1: LINEAR BACK CALCULATION
In this phase of analysis, we conduct linear back-calculation on a subset of relatively high-age fish in our dataset to generate estimates of total length for fish at earlier ages. These estimates are not to be considered independent measurements of age and length, because they are calculated based on the assumption of a direct, one-to-one proportional relationship between an individual's total length and the radii of each annulus in the individual's otolith. Each back-calculated length is therefore an estimate of that individual's length at an earlier age. However, given a large sample size, these estimates can be used to approximate or represent lower age estimates within a population.

### STEP 1: Set "device type" in the package RFishBC (Ogle, 2022) so that the GUI will be readible by MAC OS; run the Rmd chunk below.
In this step, I needed to run a line of code built into the RFishBC package to set the computing device type to "X11", which allows the package's GUI to run on a MAC OS. 

##### Set device type to MAC (X11):
```{r}
RFBCoptions(deviceType = "X11")
```

### STEP 2: Copy raw otolith images into the working directory (`growth_analysis/`).
The RFishBC package requires that raw otolith images being read for back-calculation are placed in the working directory for the Rmd file, which, in this case, is the growth_analysis folder. We therefore *temporarily* copied all raw otolith camera images (`../raw_data/otolith_images/raw/`) into the current working directory.

### STEP 3: Estimate radial measurements of otolith annuli.
In this step, we run the function "digitizeRadii()" from the package RFishBC on each otolith image independently (we list the function for all unique image IDs), which allows interactive radial measurements by drawing radius transects directly on the image. The user is asked to (1) input a unique image ID, (2) draw a linear transect from the nucleus (centroid) to the outer edge of the otolith, and (3) identify each annulus along the transect to match the inferred age of the fish. One output of the function is a data table ("radii", an element of the .rds object) giving the total radius of the otolith and the radii for each individual annulus.

We input the ID given for each otolith (e.g., FBS01, FBS02, etc.). We drew transects from the centroid to the outer edge of the otolith on the same side and just above the sulcus (see Figure S2 in the final manuscript) to standardize radii for each otolith. We identified annuli by placing a reference point on the outermost edge of each annulus. For any otoliths that were cracked (and we could not reliably determine the radius from the nucleus to an otolith edge), cloudy or obscured, or without clearly defined edges, we did not include those samples, and they are indicated within the code chunk.

#### 3a: Estimate radial measurements for Big Sugar Creek samples; run the Rmd chunk below:
In this step, we estimate radial measurements for the Big Sugar Creek samples only.

##### Run linear-back calculation on each image and generate output radius data:
```{r}
# Run linear back-calculation for Big Sugar Creek samples ("FBS")
digitizeRadii("FBS01.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS02.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS03.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS04.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS05.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS06.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS07.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS08.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS09.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS10.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS11.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS12.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS13.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS14.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS15.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS16.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS17.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS18.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS19.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS20.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS21.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS22.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS23.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS24.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS25.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS26.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS27.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS28.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS29.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS30.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS31.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS32.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS33.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS34.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS35.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS36.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS37.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS38.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS39.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS40.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS41.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS42.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS43.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS44.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS45.PNG", edgeIsAnnulus = F)
digitizeRadii("FBS46.PNG", edgeIsAnnulus = F)
```

<b>Samples used for back-calculation</b>: <i>N</i> = 46

#### 3b: Estimate radial measurements for Elk River samples; run the Rmd chunk below:
In this step, we estimate radial measurements for the Elk River samples only.

```{r}
# Run linear back-calculation for Elk River samples ("FER")
digitizeRadii("FER01.PNG", edgeIsAnnulus = F)
digitizeRadii("FER02.PNG", edgeIsAnnulus = F)
digitizeRadii("FER03.PNG", edgeIsAnnulus = F)
digitizeRadii("FER04.PNG", edgeIsAnnulus = F)
digitizeRadii("FER05.PNG", edgeIsAnnulus = F)
digitizeRadii("FER06.PNG", edgeIsAnnulus = F)
digitizeRadii("FER07.PNG", edgeIsAnnulus = F)
#digitizeRadii("FER08.PNG", edgeIsAnnulus = F) ## Cracked otolith, unable to reliably determine radius from nucleus to edge
digitizeRadii("FER09.PNG", edgeIsAnnulus = F)
digitizeRadii("FER10.PNG", edgeIsAnnulus = F)
digitizeRadii("FER11.PNG", edgeIsAnnulus = F)
digitizeRadii("FER12.PNG", edgeIsAnnulus = F)
digitizeRadii("FER13.PNG", edgeIsAnnulus = F)
digitizeRadii("FER14.PNG", edgeIsAnnulus = F)
digitizeRadii("FER15.PNG", edgeIsAnnulus = F)
digitizeRadii("FER16.PNG", edgeIsAnnulus = F)
digitizeRadii("FER17.PNG", edgeIsAnnulus = F)
digitizeRadii("FER18.PNG", edgeIsAnnulus = F)
digitizeRadii("FER19.PNG", edgeIsAnnulus = F)
digitizeRadii("FER20.PNG", edgeIsAnnulus = F)
digitizeRadii("FER21.PNG", edgeIsAnnulus = F)
digitizeRadii("FER22.PNG", edgeIsAnnulus = F)
digitizeRadii("FER23.PNG", edgeIsAnnulus = F)
digitizeRadii("FER24.PNG", edgeIsAnnulus = F)
digitizeRadii("FER25.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER26.PNG", edgeIsAnnulus = F)
digitizeRadii("FER27.PNG", edgeIsAnnulus = F)
digitizeRadii("FER28.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER29.PNG", edgeIsAnnulus = F)
digitizeRadii("FER30.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER31.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER32.PNG", edgeIsAnnulus = F)
digitizeRadii("FER33.PNG", edgeIsAnnulus = F)
digitizeRadii("FER34.PNG", edgeIsAnnulus = F)
digitizeRadii("FER35.PNG", edgeIsAnnulus = F)
digitizeRadii("FER36.PNG", edgeIsAnnulus = F)
digitizeRadii("FER37.PNG", edgeIsAnnulus = F)
digitizeRadii("FER38.PNG", edgeIsAnnulus = F)
digitizeRadii("FER39.PNG", edgeIsAnnulus = F)
digitizeRadii("FER40.PNG", edgeIsAnnulus = F)
digitizeRadii("FER41.PNG", edgeIsAnnulus = F)
digitizeRadii("FER42.PNG", edgeIsAnnulus = F)
digitizeRadii("FER43.PNG", edgeIsAnnulus = F)
digitizeRadii("FER44.PNG", edgeIsAnnulus = F)
digitizeRadii("FER45.PNG", edgeIsAnnulus = F)
digitizeRadii("FER46.PNG", edgeIsAnnulus = F)
#digitizeRadii("FER47.PNG", edgeIsAnnulus = F) # Cracked otolith, missing sulcus, unable to reliably determine radius from nucleus to edge
digitizeRadii("FER48.PNG", edgeIsAnnulus = F)
digitizeRadii("FER49.PNG", edgeIsAnnulus = F)
digitizeRadii("FER50.PNG", edgeIsAnnulus = F)
digitizeRadii("FER51.PNG", edgeIsAnnulus = F)
digitizeRadii("FER52.PNG", edgeIsAnnulus = F)
digitizeRadii("FER53.PNG", edgeIsAnnulus = F)
digitizeRadii("FER54.PNG", edgeIsAnnulus = F) 
digitizeRadii("FER55.PNG", edgeIsAnnulus = F)
digitizeRadii("FER56.PNG", edgeIsAnnulus = F)
digitizeRadii("FER57.PNG", edgeIsAnnulus = F)
digitizeRadii("FER58.PNG", edgeIsAnnulus = F)
digitizeRadii("FER59.PNG", edgeIsAnnulus = F)
digitizeRadii("FER60.PNG", edgeIsAnnulus = F)
digitizeRadii("FER61.PNG", edgeIsAnnulus = F)
digitizeRadii("FER62.PNG", edgeIsAnnulus = F)
digitizeRadii("FER63.PNG", edgeIsAnnulus = F)
digitizeRadii("FER64.PNG", edgeIsAnnulus = F)
digitizeRadii("FER65.PNG", edgeIsAnnulus = F)
digitizeRadii("FER66.PNG", edgeIsAnnulus = F)
digitizeRadii("FER68.PNG", edgeIsAnnulus = F)
digitizeRadii("FER69.PNG", edgeIsAnnulus = F)
#digitizeRadii("FER70.PNG", edgeIsAnnulus = F) # Poor image quality
digitizeRadii("FER71.PNG", edgeIsAnnulus = F)
```

<b>Samples used for back-calculation</b>: <i>N</i> = 62

#### 3c: Remove all copied raw otolith images from the working directory.

#### 3d: Move all .rds files generated from the digitizeRadii() function into a new folder: `data/bc_rds/`

### STEP 4: Compile and clean all radius measurements stored in .rds files
In this step, we wrote a for-loop to extract the "radii" elements from each of the .rds files generated by the digitizeRadii() function used in Step 3 above. All radii data were for each sample were then compiled into a single dataframe ("bc"). We then cleaned, filtered, and merged the bc data with total length data to perform linear back-calculation of length-at-age.

#### 4a: Extract radial measurements for each sample from .rds files and compile into a single data frame for back-calculation

##### Extract radial measurements and compile into single dataframe:
```{r}
# List rds filers
rds <- list.files(paste("data/bc_rds/"),
                  pattern=".rds$")

# Generate data frame of rds file names
rds_files <- data_frame(rds)

# Generate an empty list to store "radii" data frame elements from .rds files
rds_list <- list()

# Run for loop on all .rds files to extract radii data frame and add to the rds_list (defined above)
for(ii in 1:nrow(rds_files)) {
  
  ## paste the readRDS() function so that it calls each .rds file in the rds files data frame
  read_rds <- readRDS(paste("data/bc_rds/", rds_files[ii,"rds"], sep = ""))$radii
  
  ## Fill the empty list with the iterative output of each read_rds object (defined above)
  rds_list[[paste0("element",ii)]] <- read_rds
  
}

# Concatenate all data frame elements in the list using the list.rbind() function from the package "rlist"
bc <- data.frame(list.rbind(rds_list))
```

#### 4b: Clean and filter radial measurement data for downstream back-calculation; run the Rmd chunk below.
In this step, we clean and filter the radial measurement data so that it can be seamlessly merged with the full ancestry dataset (See Step 5).

Data from the compiled rds files include: 

   1. "sample_id": same as in metadata and genotype data (followed by "structure_number"; see Analysis 3, Phase 1, step 1e)
   2. "consensus age": ultimate age estimate based on consensus of three agers, Eddie, Joe, and Michael 
   3. "annulus": each annulus for each otolith
   4. "annulus_radius": radius of each annulus 
   5. "otolith_radius": total radius of the whole otolith

##### Clean and filter, and merge radial measurement data:
```{r}
# Omit rownames
rownames(bc) <- NULL

# Omit empty "reading" column
bc <- bc %>%
  select(-c(reading))

# Modify column names to be more sensible
colnames(bc) <- c("sample_id", "consensus_age", "annulus", "annulus_radius", "otolith_radius")

# Here, I added a row for each of the samples we did not do radius measurements for. I included these as individual rows, because without them, the merging procedure in step 5 results in "NA" values for these individuals since they do not have radial measurements and cannot be used for back-calculation.
bc[451,] <- c("FER08", "2", "2", "1.0000000", "1.0000000")
bc[452,] <- c("FER47", "2", "2", "1.0000000", "1.0000000")
bc[453,] <- c("FER70", "2", "2", "1.0000000", "1.0000000")

# Convert characters to factors
bc <- bc %>%
  mutate(sample_id = factor(sample_id)) %>%
  mutate(consensus_age = as.numeric(consensus_age)) %>%
  mutate(annulus = as.numeric(annulus)) %>%
  mutate(annulus_radius = as.numeric(annulus_radius)) %>%
  mutate(otolith_radius = as.numeric(otolith_radius))

# Save radius data for donwtream analyses
save(bc, file = "data/bc_data/bc.Rda")
```

### STEP 5: Merge radius data with full ancestry data (Analysis 3) and perform linear back-calculation 
In this step, we merge the annuli radii data generated above with the full ancestry data generated in Analysis 3, and we perform linear back-calculation using the Dahl-Lea direct proportion model with total length. We estimate length-at-age for each individual fish (age of the fish at all earlier ages) based on the assumed proportional relationship between total length of the fish at a given age and the radius of the fish at the corresponding annulus deposition.

#### 5a: Merge radius data with full ancestry data; run the Rmd chunk below.

##### Merge radius data with full ancestry data:
```{r}
# Load in full ancestry data curated in Analysis 3 
load("../ancestry_analysis/data/processed_ancestry_data/full_ancestry_data.Rda")

# Filter dataset to keep only fish with total length and consensus age data ("sample"; NOT "reference")
full_ancestry_data <- full_ancestry_data %>%
  filter(population == "sample")

# Load in bc data calculated in Steps 3-4 above
load("data/bc_data/bc.Rda")

# Merge full ancestry data with bc data 
bc_data <- full_join(full_ancestry_data, 
                     bc, 
                     by = c("sample_id", "consensus_age"))

# Perform back-calculation using the Dahl-Lee model
bc_data <- bc_data %>%
  mutate(bc_ratio = annulus_radius/otolith_radius) %>%
  mutate(bc_tl = tl_alive*(annulus_radius/otolith_radius))
```

#### 5b: Remove all length data corresponding to an annulus-to-otolith radial ratio of 1.00; run the Rmd chunk below.
In this step, we standardize all total length data such that the consensus age of the fish (determined by estimating the number of annuli deposited on each otolith) corresponds to the radial measurement of the last deposited otolith, rather than the edge of the otolith. For each fish, the margin of the otolith beyond the final annulus represents additional deposition of calcium carbonate over the course of the year; the exact timing of yearly deposition is dependent on the birth date (exact day) of the fish, which may be variable among fish in our sample. Thus, to standardize length-at-age, we only include back-calculated age data corresponding to each annulus, and not to the edge of the otolith. We therefore do not use the observed lengths of fish collected in the field.

From this point further, the column for "consensus_age", which was the age agreed upon for each fish based on the number of annuli present on the otolith, was considered synonmous with the column "annulus", with the highest annulus number for each sample being equivalent to the consensus age. Each lesser annulus number represents earlier ages for each fish, for which total length is back-calculated.

##### Remove fish with annulus-to-otolith radial ratio of 1.00:
```{r}
# Remove fish with annulus-to-otolith radial ratio of 1.00
full_bc_data <- bc_data %>%
  filter(bc_ratio != 1.0000000)

## Verify that the three samples not back-calculated ((FER08, FER47, FER70) were removed from the dataset

# Samples in full_bc_data but not in bc_data
full_bc_data %>% 
  filter(!full_bc_data$sample_id %in% bc_data$sample_id)

# Samples in bc_data but not in full_bc_data
bc_data %>% 
  filter(!bc_data$sample_id %in% full_bc_data$sample_id)

# Save full bc data for downstream growth analysis
save(full_bc_data, file = "data/global_data/full_bc_data.Rda")
```

After this step, three samples (FER08, FER47, FER70) were omitted from analyses, because we were unable to measure radii for back-calculation (see Steps 3-4 above). These samples were not included in any growth models.

<b>Final back-calculation data summary</b>:
<i>N</i><sub>samples</sub> = 337

## PHASE 2: VON BERTALANFFY GROWTH ANALYSIS
In this phase of the analysis, we paramaterize the von Bertalanffy growth equation using back-calculated total length and consensus age of samples in the Elk River and Big Sugar Creek to assess patterns of growth in groups of interest (specifically, between the two streams, between sexes, and among genetic ancestry groups). We first quantify overall growth rate and maximum theoretical total length for all fish in the dataset to understand average growth rates across the populations of interest. Next, we quantify any potential differences in growth by (1) individual sex (male or female) or (2) by stream (Big Sugar Creek or Elk River) to account for variation which may bias results in other groups. Finally, we assess differences in growth based on ancestry group membership as inferred by STRUCTURE analysis in Analysis 3 (Neosho Bass, Smallmouth Bass, Admixed). For all growth assessments, we include linear back-calculated length-at-age estimates for large, older fish to increase sample size.

### STEP 1: Define the von Bertlanffy growth model; run the Rmd chunk below.
In this step, we use the vbFuns() function in the R package FSA to generate a function using the "typical" parameterization of the von Bertlanffy equation.

##### Define von Bertalanffy growth model:
```{r}
vb <- vbFuns(param = "Typical")
```

### STEP 2: Parameterize the von Bertalanffy model for study groups of interest.

#### 2a: Generate global growth model.
In this step, we parameterize the von Bertalanffy growth model for the global dataset (all samples), including all fish in the study (across Big Sugar Creek and Elk River, both sexes and all ancestry groups).

##### 2a.1. Load full back-calculation data and generaate model starting values; run the Rmd chunk below.

##### load data and generate starting values
```{r}
# Load full bc data
load("data/global_data/full_bc_data.Rda")

# Generate starting values for optimizing the von Bertalanffy model
global_starts <- vbStarts(bc_tl ~ annulus, 
                            data = full_bc_data)
```

<b>Starting values used for global model</b>: <br>

<b>L<sub>inf</sub></b>: 382.0127 <br>
<b>K</b>: 0.4094681 <br>
<b>t<sub>0</sub></b>: -0.07894399 <br>

##### 2a.2. Model growth for the global dataset and extract model coefficients; run the Rmd chunk below.
In this step, we run the non-linear von Bertalanffy model for the global dataset and extract model coefficients from the summary table given with the summary() function.

##### Model von Bertalanffy growth:
```{r}
# Run von Bertalanffy growth model using back-calculated total length, modeled by annulus number (consensus age)
global <- nls(bc_tl ~ vb(annulus,
                         Linf,
                         K,
                         t0), 
              data = full_bc_data, 
              start = global_starts)

# Extract global data coefficients
global_coefficients <- summary(global)
```

<b>Parameter estimates for global model</b>: <br>

<b>L<sub>inf</sub></b>: 440.94667 <br>
<b>K</b>: 0.28338 <br>
<b>t<sub>0</sub></b>: -0.30329 <br>

Parameter estimates are given in Table S3a in the final manuscript.

##### 2a.3. Perform bootstrapping of global data to estimate 95% confidence intervals around each parameter estimate; run the Rmd chunk below.
In this step, we perform bootstrapping on the global dataset with 9999 bootstrap replicates and calculate 95% confidence intervals around the parameter estimates given in the global model (see Step 2a.2).

##### Perform bootstrapping on global model:
```{r}
# Conduct bootstrapping on parameter estimates
set.seed(34349) # Set seed so that results are reproducible
global_bootstrap <- Boot(global, 
                         R = 9999)

# Calculate bootstrapped 95% confidence intervals for parameter estimates
global_confint <- confint(global_bootstrap, 
                          level = 0.95)
```
<b>Confidence intervals for global parameter estimates</b>: <br>

<b>L<sub>inf</sub></b>: 408.4898281 - 485.3221992 <br>
<b>K</b>: 0.2287383 - 0.3429249 <br>
<b>t<sub>0</sub></b>: -0.5030147 - -0.1412999 <br>

Results from bootstrapping and confidence intervals are given in Table S3a in the final manuscript.

##### 2a.4. Perform bootstrapping of predicted average length-at-age values and calculate 95% confidence intervals; run the Rmd chunk below.
In this step, we perform bootstrapping over average length-at-age estimates predicted for the dataset and calculate 95% confidence intervals around the parameter estimates.

##### Conduct bootstrapping over predicted values:
```{r}
# Define function to predict average length-at-age values for each age (to plot the best fit curve for the von Bertlanffy growth model)
predict_function <- function(x) {
  predict(x, 
          data.frame(annulus = annuli))
}

# Define range of theoretical annulus values over which to calculate length-at-age
annuli <- seq(-1, 15, by = 0.2)

# Conduct bootstrapping with 9999 bootstrap replicates to calculate confidence intervals around the best fit curve
global_iboot <- Boot(global, 
                     f = predict_function,
                     R = 9999)

# Calculate bootstrapped 95% confidence intervals for all parameter estimates
global_iconfint <- confint(global_iboot, 
                           level = 0.95)

# Predict average back-calculated length-at-age for all fish based on model fit and confidence intervals
global_predict <- data.frame(annulus,
                             predict(global, data.frame(annulus = annuli)),
                             global_iconfint)

# Modify column names (lci = lower confidence interval [2.5%]; uci = upper confidence interval [97.5%])
colnames(global_predict) <- c("annulus","fit","lci","uci")

# Save the predicted global model dataset for donwstream analyses
save(global_predict, file = "data/global_data/global_predict.Rda")
```

##### 2a.5. Plot von Bertlanffy growth for the global dataset; run the Rmd chunk below.

##### Plot the von Bertalanffy model for the global dataset: `figures/global.pdf`
```{r}
# Load in global predicted dataset to plot best fit curve
load("data/global_data/global_predict.Rda")

# Load in full back-calculuated data to plot all data points
load("data/global_data/full_bc_data.Rda")

# Plot von Bertalanffy model
pdf("figures/global.pdf", width = 7, height = 5)

ggplot() + 
  geom_ribbon(data = global_predict, aes(x = annulus, ymin = lci, ymax = uci, fill = "grey", 0.3), show.legend = T) +
  geom_point(data = full_bc_data, aes(x = annulus, y = bc_tl, fill = "grey"), show.legend = F, size = 3, pch = 21, position = position_jitter(width = 0.2)) + 
  geom_line(data = global_predict, aes(x = annulus, y = fit)) +
  geom_hline(yintercept = 440.94667, linetype = "longdash", size = 0.8, color = "blue") +
  theme_set(theme_cowplot(12)) +
  scale_fill_manual(values = c("grey")) +
  scale_y_continuous(name = "Back-calculated total length (mm)", limits = c(0,500), expand = c(0,0)) +
  scale_x_continuous(name = "Annulus (years)", expand = c(0,0), limits = c(0,15), breaks = seq(0,15,1)) +
  theme(axis.title = element_text(size = 15)) + 
  theme(axis.text = element_text(size = 15)) +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

dev.off()
```

This figure is the basis for Figure 2a in the final manuscript.

#### 2b: Generate growth model for each river (Big Sugar Creek, Elk River) separately.
In this step, we parameterize the von Bertalanffy growth model for each stream population (Big Sugar Creek and Elk River) to assess potential differences in growth due to stream ecology.

##### 2b.1. Load full back-calculation data and separate into datasets by stream; run the Rmd chunk below.

##### Separate global dataset by river:
```{r}
# Load full bc data
load("data/global_data/full_bc_data.Rda")

# Get Big Sugar Creek samples only
full_bc_data_bs <- full_bc_data %>%
  filter(river == "Big_Sugar")

# Get Elk River samples only
full_bc_data_elk <- full_bc_data %>%
  filter(river == "Elk_River")

# save Big Sugar Creek data for downstream analyses
save(full_bc_data_bs, file = "data/river_data/full_bc_data_bs.Rda")

# save Elk River data for downstream analyses
save(full_bc_data_elk, file = "data/river_data/full_bc_data_elk.Rda")
```

##### 2b.2. Generate model starting values for each river; run the Rmd chunk below.

##### load data and generate starting values for rivers:
```{r}
# Load full bc data for Big Sugar Creek
load("data/river_data/full_bc_data_bs.Rda")

# Load full bc data for Elk River
load("data/river_data/full_bc_data_elk.Rda")

# Generate starting values for optimizing the von Bertalanffy model in Big Sugar Creek
bs_starts <- vbStarts(bc_tl ~ annulus, 
                      data = full_bc_data_bs)

# Generate starting values for optimizing the von Bertalanffy model in Elk River
elk_starts <- vbStarts(bc_tl ~ annulus, 
                       data = full_bc_data_elk)
```

<b>Starting values used for Big Sugar Creek model</b>: <br>

<b>L<sub>inf</sub></b>: 455.5685 <br>
<b>K</b>: 0.2670832 <br>
<b>t<sub>0</sub></b>: -0.2545336 <br>

<b>Starting values used for Elk River model</b>: <br>

<b>L<sub>inf</sub></b>: 381.0677 <br>
<b>K</b>: 0.4223898 <br>
<b>t<sub>0</sub></b>: -0.09427 <br>

##### 2b.3. Model growth for each river population and extract model coefficients; run the Rmd chunk below.
In this step, we run the non-linear von Bertalanffy model for each river dataset and extract model coefficients from the summary table given with the summary() function.

##### Model von Bertalanffy growth for rivers:
```{r}
# Run von Bertalanffy growth model using back-calculated total length, modeled by annulus number (consensus age)
bs <- nls(bc_tl ~ vb(annulus,
                     Linf,
                     K,
                     t0), 
          data = full_bc_data_bs, 
          start = bs_starts)

# Extract Big Sugar data coefficients
bs_coefficients <- summary(bs)

# Run von Bertalanffy growth model using back-calculated total length, modeled by annulus number (consensus age)
elk <- nls(bc_tl ~ vb(annulus,
                      Linf,
                      K,
                      t0), 
           data = full_bc_data_elk, 
           start = elk_starts)

# Extract Big Sugar data coefficients
elk_coefficients <- summary(elk)
```

<b>Parameter estimates for Big Sugar Creek model</b>: <br>

<b>L<sub>inf</sub></b>: 464.18395 <br>
<b>K</b>: 0.25180 <br>
<b>t<sub>0</sub></b>: -0.30943 <br>

<b>Parameter estimates for Elk River model</b>: <br>

<b>L<sub>inf</sub></b>: 430.14416 <br>
<b>K</b>: 0.30578 <br>
<b>t<sub>0</sub></b>: -0.28753 <br>

Parameter estimates are given in Table S3b in the final manuscript.

##### 2b.4. Perform bootstrapping of river population datasets to estimate 95% confidence intervals around each parameter estimate; run the Rmd chunk below.
In this step, we perform bootstrapping on each river population dataset with 9999 bootstrap replicates and calculate 95% confidence intervals around the parameter estimates given in the Big Sugar Creek and Elk River models (see Step 2b.3).

##### Perform bootstrapping on Big Sugar Creek and Elk River models:
```{r}
# Conduct bootstrapping on parameter estimates for Big Sugar Creek model
set.seed(49504) # Set seed so that results are reproducible
bs_bootstrap <- Boot(bs, 
                     R = 9999)

# Calculate bootstrapped 95% confidence intervals for parameter estimates for Big Sugar Creek model
bs_confint <- confint(bs_bootstrap, 
                      level = 0.95)

# Conduct bootstrapping on parameter estimates for Elk River model
set.seed(57458) # Set seed so that results are reproducible
elk_bootstrap <- Boot(elk, 
                     R = 9999)

# Calculate bootstrapped 95% confidence intervals for parameter estimates for Elk River model
elk_confint <- confint(elk_bootstrap, 
                      level = 0.95)
```

<b>Confidence intervals for Big Sugar Creek parameter estimates</b>: <br>

<b>L<sub>inf</sub></b>: 417.9443640 - 556.1500369 <br>
<b>K</b>: 0.1771707 - 0.3226116 <br>
<b>t<sub>0</sub></b>: -0.6254293 - 0.1084089 <br>

<b>Confidence intervals for Elk River parameter estimates</b>: <br>

<b>L<sub>inf</sub></b>: 391.2426135 - 490.53084606 <br>
<b>K</b>: 0.2246298 - 0.39204444 <br>
<b>t<sub>0</sub></b>: -0.5779102 - -0.07034693 <br>

Results from bootstrapping and confidence intervals are given in Table S3b in the final manuscript.

##### 2b.5. Perform bootstrapping of predicted average length-at-age values and calculate 95% confidence intervals; run the Rmd chunk below.
In this step, we perform bootstrapping over average length-at-age estimates predicted for the Big Sugar Creek and Elk River datasets and calculate 95% confidence intervals around the parameter estimates.

We use the function and sequence of annulus values ("annuli") defined in Step 2a.4 (above). 

##### Conduct bootstrapping over predicted values for rivers:
```{r}
## Conduct bootstrapping and calculated confidence intervals for Big Sugar Creek

# Conduct bootstrapping with 9999 bootstrap replicates to calculate confidence intervals around the best fit curve
bs_iboot <- Boot(bs, 
                 f = predict_function,
                 R = 9999)

# Calculate bootstrapped 95% confidence intervals for all parameter estimates
bs_iconfint <- confint(bs_iboot, 
                       level = 0.95)

# Predict average back-calculated length-at-age for all fish based on model fit and confidence intervals
bs_predict <- data.frame(annulus,
                         predict(bs, data.frame(annulus = annuli)),
                         bs_iconfint)

# Generate column to distinguish these data as Big Sugar Creek
bs_predict$river <- c(rep("Big_Sugar", times = 81))

# Modify column names (lci = lower confidence interval [2.5%]; uci = upper confidence interval [97.5%])
colnames(bs_predict) <- c("annulus","fit","lci","uci", "river")


## Conduct bootstrapping and calculated confidence intervals for Elk River

# Conduct bootstrapping with 9999 bootstrap replicates to calculate confidence intervals around the best fit curve
elk_iboot <- Boot(elk, 
                  f = predict_function,
                  R = 9999)

# Calculate bootstrapped 95% confidence intervals for all parameter estimates
elk_iconfint <- confint(elk_iboot, 
                        level = 0.95)

# Predict average back-calculated length-at-age for all fish based on model fit and confidence intervals
elk_predict <- data.frame(annulus,
                          predict(elk, data.frame(annulus = annuli)),
                          elk_iconfint)

# Generate column to distinguish these data as Elk River
elk_predict$river <- c(rep("Elk_River", times = 81))

# Modify column names (lci = lower confidence interval [2.5%]; uci = upper confidence interval [97.5%])
colnames(elk_predict) <- c("annulus","fit","lci","uci", "river")

## Save predicted datasets for downstream analyses 

# Save the predicted Big Sugar Creek model dataset for donwstream analyses
save(bs_predict, file = "data/river_data/bs_predict.Rda")

# Save the predicted Elk River model dataset for donwstream analyses
save(elk_predict, file = "data/river_data/elk_predict.Rda")
```

##### 2b.6. Plot von Bertlanffy growth for rivers; run the Rmd chunk below.

##### Plot the von Bertalanffy model for rivers: `figures/river.pdf`
```{r}
# Load in Big Sugar Creek predicted dataset to plot best fit curve
load("data/river_data/bs_predict.Rda")

# Load in Elk River predicted dataset to plot best fit curve
load("data/river_data/elk_predict.Rda")

# Load in full back-calculuated data to plot all data points
load("data/global_data/full_bc_data.Rda")

# Bind Big Sugar Creek and Elk River datasets for plotting
river_predict <- rbind(bs_predict,
                       elk_predict)

# Convert character to factor for 
river_predict <- river_predict %>%
  mutate(river = factor(river))

# Plot von Bertalanffy model
pdf("figures/river.pdf", width = 7, height = 5)

ggplot() + 
  geom_ribbon(data = river_predict, aes(x = annulus, ymin = lci, ymax = uci, fill = river, alpha = 0.2), show.legend = T) +
  geom_point(data = full_bc_data, aes(x = annulus, y = bc_tl, fill = river), show.legend = F, size=3, pch=21, position = position_jitter(width = 0.2)) + 
  geom_line(data = river_predict, aes(x = annulus, y = fit, linetype = river), show.legend = F) +
  theme_set(theme_cowplot(12)) +
  geom_hline(yintercept = 464.18395, linetype = "solid", size = 0.8, color = "blue") +
  geom_hline(yintercept = 430.14416, linetype = "dotted", size = 0.8, color = "blue") +
  scale_fill_manual(values = c("grey80","grey20")) +
  scale_y_continuous(name = "Back-calculated total length (mm)", limits = c(0,550), expand = c(0,0)) +
  scale_x_continuous(name = "Annulus (years)", expand = c(0,0), limits = c(0,15), breaks = seq(0,15,1)) +
  theme(axis.title = element_text(size = 15)) + 
  theme(axis.text = element_text(size = 15)) +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1))

dev.off()
```

This figure is the basis for Figure 2b in the final manuscript.

#### 2c: Generate growth model for each sex (Male, Female) separately.
In this step, we parameterize the von Bertalanffy growth model for each sex (Male, Female) to assess potential differences in growth due to sexual dimorphism.

##### 2c.1. Load full back-calculation data and separate into datasets by sex; run the Rmd chunk below.

##### Separate global dataset by sex:
```{r}
# Load full bc data
load("data/global_data/full_bc_data.Rda")

# Get male samples only
full_bc_data_m <- full_bc_data %>%
  filter(sex == "Male")

# Get female samples only
full_bc_data_f <- full_bc_data %>%
  filter(sex == "Female")

# save male data for downstream analyses
save(full_bc_data_m, file = "data/sex_data/full_bc_data_m.Rda")

# save female data for downstream analyses
save(full_bc_data_f, file = "data/sex_data/full_bc_data_f.Rda")
```

##### 2c.2. Generate model starting values for each sex; run the Rmd chunk below.

##### load data and generate starting values for sex:
```{r}
# Load full bc data for males
load("data/sex_data/full_bc_data_m.Rda")

# Load full bc data for females
load("data/sex_data/full_bc_data_f.Rda")

# Generate starting values for optimizing the von Bertalanffy model in males
m_starts <- vbStarts(bc_tl ~ annulus, 
                     data = full_bc_data_m)

# Generate starting values for optimizing the von Bertalanffy model in females
f_starts <- vbStarts(bc_tl ~ annulus, 
                     data = full_bc_data_f)
```

<b>Starting values used for male model</b>: <br>

<b>L<sub>inf</sub></b>: 436.1392 <br>
<b>K</b>: 0.3052123 <br>
<b>t<sub>0</sub></b>: -0.2546104 <br>

<b>Starting values used for Elk River model</b>: <br>

<b>L<sub>inf</sub></b>: 383.0877 <br>
<b>K</b>: 0.3944219 <br>
<b>t<sub>0</sub></b>: -0.09356921 <br>

##### 2c.3. Model growth for each sex and extract model coefficients; run the Rmd chunk below.
In this step, we run the non-linear von Bertalanffy model for each sex and extract model coefficients from the summary table given with the summary() function.

##### Model von Bertalanffy growth for sex:
```{r}
# Run von Bertalanffy growth model for males using back-calculated total length, modeled by annulus number (consensus age)
m <- nls(bc_tl ~ vb(annulus,
                    Linf,
                    K,
                    t0), 
         data = full_bc_data_m, 
         start = m_starts)

# Extract male data coefficients
m_coefficients <- summary(m)

# Run von Bertalanffy growth model for females using back-calculated total length, modeled by annulus number (consensus age)
f <- nls(bc_tl ~ vb(annulus,
                    Linf,
                    K,
                    t0), 
         data = full_bc_data_f, 
         start = f_starts)

# Extract female data coefficients
f_coefficients <- summary(f)
```

<b>Parameter estimates for male model</b>: <br>

<b>L<sub>inf</sub></b>: 445.5611 <br>
<b>K</b>: 0.2894 <br>
<b>t<sub>0</sub></b>: -0.2842 <br>

<b>Parameter estimates for female model</b>: <br>

<b>L<sub>inf</sub></b>: 440.35229 <br>
<b>K</b>: 0.27610 <br>
<b>t<sub>0</sub></b>: -0.31403 <br>

Parameter estimates are given in Table S3c in the final manuscript.

##### 2a.4. Perform bootstrapping on sex datasets to estimate 95% confidence intervals around each parameter estimate; run the Rmd chunk below.
In this step, we perform bootstrapping on each sex with 9999 bootstrap replicates and calculate 95% confidence intervals around the parameter estimates given in the male and female growth models (see Step 2c.3).

##### Perform bootstrapping on male and female models:
```{r}
# Conduct bootstrapping on parameter estimates for male model
set.seed(53744) # Set seed so that results are reproducible
m_bootstrap <- Boot(m, 
                    R = 9999)

# Calculate bootstrapped 95% confidence intervals for parameter estimates for male model
m_confint <- confint(m_bootstrap, 
                     level = 0.95)

# Conduct bootstrapping on parameter estimates for female model
set.seed(340985) # Set seed so that results are reproducible
f_bootstrap <- Boot(f, 
                    R = 9999)

# Calculate bootstrapped 95% confidence intervals for parameter estimates for female model
f_confint <- confint(f_bootstrap, 
                     level = 0.95)
```

<b>Confidence intervals for male parameter estimates</b>: <br>

<b>L<sub>inf</sub></b>: 407.1501469 - 511.6867181 <br>
<b>K</b>: 0.2137145 - 0.3718532 <br>
<b>t<sub>0</sub></b>: -0.5874782 - -0.0678828 <br>

<b>Confidence intervals for female parameter estimates</b>: <br>

<b>L<sub>inf</sub></b>: 396.3111777 - 515.08685844 <br>
<b>K</b>: 0.1967684 - 0.35531175 <br>
<b>t<sub>0</sub></b>: -0.6221602 - -0.09637011 <br>

Results from bootstrapping and confidence intervals are given in Table S3c in the final manuscript.

##### 2c.5. Perform bootstrapping of predicted average length-at-age values and calculate 95% confidence intervals; run the Rmd chunk below.
In this step, we perform bootstrapping over average length-at-age estimates predicted for the male and female datasets and calculate 95% confidence intervals around the parameter estimates.

We use the function and sequence of annulus values ("annuli") defined in Step 2a.4 (above). 

##### Conduct bootstrapping over predicted values:
```{r}
## Conduct bootstrapping and calculated confidence intervals for males

# Conduct bootstrapping with 9999 bootstrap replicates to calculate confidence intervals around the best fit curve
m_iboot <- Boot(m, 
                f = predict_function,
                R = 9999)

# Calculate bootstrapped 95% confidence intervals for all parameter estimates
m_iconfint <- confint(m_iboot, 
                      level = 0.95)

# Predict average back-calculated length-at-age for all fish based on model fit and confidence intervals
m_predict <- data.frame(annulus,
                        predict(m, data.frame(annulus = annuli)),
                        m_iconfint)

# Generate column to distinguish these data as male
m_predict$sex <- c(rep("Male", times = 81))

# Modify column names (lci = lower confidence interval [2.5%]; uci = upper confidence interval [97.5%])
colnames(m_predict) <- c("annulus","fit","lci","uci", "sex")


## Conduct bootstrapping and calculated confidence intervals for females

# Conduct bootstrapping with 9999 bootstrap replicates to calculate confidence intervals around the best fit curve
f_iboot <- Boot(f, 
                f = predict_function,
                R = 9999)

# Calculate bootstrapped 95% confidence intervals for all parameter estimates
f_iconfint <- confint(f_iboot, 
                      level = 0.95)

# Predict average back-calculated length-at-age for all fish based on model fit and confidence intervals
f_predict <- data.frame(annulus,
                        predict(f, data.frame(annulus = annuli)),
                        f_iconfint)

# Generate column to distinguish these data as female
f_predict$sex <- c(rep("Female", times = 81))

# Modify column names (lci = lower confidence interval [2.5%]; uci = upper confidence interval [97.5%])
colnames(f_predict) <- c("annulus","fit","lci","uci", "sex")

## Save predicted datasets for downstream analyses 

# Save the predicted male model dataset for donwstream analyses
save(m_predict, file = "data/sex_data/m_predict.Rda")

# Save the predicted female model dataset for donwstream analyses
save(f_predict, file = "data/sex_data/f_predict.Rda")
```

##### 2c.6. Plot von Bertlanffy growth for sex; run the Rmd chunk below.

##### Plot the von Bertalanffy model for sex: `figures/sex.pdf`
```{r}
# Load in male predicted dataset to plot best fit curve
load("data/sex_data/m_predict.Rda")

# Load in female predicted dataset to plot best fit curve
load("data/sex_data/f_predict.Rda")

# Load in full back-calculuated data to plot all data points
load("data/global_data/full_bc_data.Rda")

# Bind male and female datasets for plotting
sex_predict <- rbind(m_predict,
                     f_predict)

# Convert character to factor
sex_predict <- sex_predict %>%
  mutate(sex = factor(sex))

# Plot von Bertalanffy model
pdf("figures/sex.pdf", width = 7, height = 5)

ggplot() + 
  geom_ribbon(data = sex_predict, aes(x = annulus, ymin = lci, ymax = uci, fill = sex, alpha = 0.2), show.legend = T) +
  geom_point(data = full_bc_data, aes(x = annulus, y = bc_tl, fill = sex), show.legend = F, size = 3, pch = 21, position = position_jitter(width = 0.2)) + 
  geom_line(data = sex_predict, aes(x = annulus, y = fit, linetype = sex), show.legend = F) +
  theme_set(theme_cowplot(12)) +
  geom_hline(yintercept = 445.5611, linetype = "dotted", size = 0.8, color = "blue") +
  geom_hline(yintercept = 440.35229, linetype = "solid", size = 0.8, color = "blue") +
  scale_fill_manual(values = c("grey80","grey20")) +
  scale_y_continuous(name = "Back-calculated total length (mm)", limits = c(0,550), expand = c(0,0)) +
  scale_x_continuous(name = "Annulus (years)", expand = c(0,0), limits = c(0,15), breaks = seq(0,15,1)) +
  theme(axis.title = element_text(size = 15)) + 
  theme(axis.text = element_text(size = 15)) +
  theme(panel.border = element_rect(colour = "black", fill = NA, size=1))

dev.off()
```

This figure is the basis for Figure 2c in the final manuscript.


